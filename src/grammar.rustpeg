use crate::ast::*;
use super::ExpressionTail;

pub program -> Program
    = body:block_body { Program{ body } }

block_body -> Vec<Expression>
    = stms:wrapped_stm* expr:expr? __ {
        let body = if let Some(expr) = expr {
            [&stms[..], &[expr]].concat()
        } else {
            stms
        };

        body
    }

wrapped_stm -> Expression
    = __ s:stm __ { s }

stm -> Expression
    = expr:expr __ ";" { expr }

expr -> Expression
    = d:declaration { Expression::Declaration(Box::new(d)) }
    / fl:function_literal { Expression::FunctionLiteral(Box::new(fl)) }
    / head:wrapped_atom tail:expr_tail* {
            let mut current = head;
            for tail_part in tail {
                current = match tail_part {
                    ExpressionTail::MemberAccess(id) =>
                        Expression::MemberAccess(Box::new(MemberAccess{
                            object: current,
                            property: id,
                        })),
                    ExpressionTail::Call(args) =>
                        Expression::Call(Box::new(Call{
                            callee: current,
                            arguments: args
                        })),
                }
            }
            current
        }

expr_tail -> ExpressionTail
    = __ "(" __ args:expr_list __ ","? __ ")" __ { ExpressionTail::Call(args) }
    / __ "." __ property:id __ { ExpressionTail::MemberAccess(property) }

expr_list -> Vec<Expression>
    = expr ** ","

wrapped_atom -> Expression
    = __ a:atom __ { a }

atom -> Expression
    = "(" __ expr:expr __ ")" { expr }
    / block:block { Expression::Block(Box::new(block)) }
    / i:id { Expression::Id(Box::new(i)) }
    / nl:number_literal { Expression::NumberLiteral(Box::new(nl)) }
    / sl:string_literal { Expression::StringLiteral(Box::new(sl)) }

block -> Block
    = "{" __ body:block_body __ "}" { Block { body } }

id -> Id
    = #quiet<name:$([a-zA-Z_][a-zA-Z_0-9]*) { Id{ name: name.to_string() } }>
    / #expected("id")

declaration -> Declaration
    = "let" __ i:id __ "=" __ e:expr { Declaration{ id: i, value: e } }

function_literal -> FunctionLiteral
    = "(" __ slots:slot_list __ ")" __  "=>" __ expression:expr {
        FunctionLiteral{
            id: Id{ name: "anonymous".to_string() },
            slots,
            expression,
        }
    }

slot_type_sufix -> Id
    = ":" __ ty:id { ty }

slot -> Slot
    = id:id __ ty:slot_type_sufix? {
        Slot { id, ty: ty.unwrap_or(Id{ name: String::from("Any") }) }
    }

wrapped_slot -> Slot
    = __ slot:slot __ { slot }

slot_list -> Vec<Slot>
    = wrapped_slot ** ","

number_literal -> NumberLiteral
    = value:$([0-9]+) { NumberLiteral{ value: value.parse().unwrap() } }

string_literal -> StringLiteral
    = "\"" value:$([^"]*) "\"" { StringLiteral{ value: value.to_string() } }

__ = #quiet<(whitespace / eol)*>

eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u{2028}"
    / "\u{2029}"

whitespace
    = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
