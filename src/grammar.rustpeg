use crate::ast::*;
use super::ExpressionTail;

pub program -> Program
    = body:block_body { Program { body } }

block_body -> Vec<Expression>
    = body:wrapped_expr ** ";" __ ";"? __ { body }

wrapped_expr -> Expression
    = __ expr:expr __ { expr }

expr -> Expression
    = d:declaration { Expression::Declaration(Box::new(d)) }
    / f:function { Expression::Function(Box::new(f)) }
    / l:lambda { Expression::Lambda(Box::new(l)) }
    / "!" __ expr:expr { Expression::Unary(Box::new(Unary{ expr, op: UnaryOperator::Not })) }
    / "+" __ expr:expr { Expression::Unary(Box::new(Unary{ expr, op: UnaryOperator::Pos })) }
    / "-" __ expr:expr { Expression::Unary(Box::new(Unary{ expr, op: UnaryOperator::Neg })) }
    / head:atom tail:expr_tail* {
        let mut full = head;
        for part in tail { full = part.prepend(full) }
        full
    }

declaration -> Declaration
    = "let" space id:id __ "=" __ value:expr { Declaration{ id, value } }

expr_tail -> ExpressionTail
    = __ "(" __ args:expr_list __ ","? __ ")" __ { ExpressionTail::Call(args) }
    / __ "." __ property:id __ { ExpressionTail::MemberAccess(property) }
    / __ "++" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Concat, right) }
    / __ "+" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Add, right) }
    / __ "-" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Sub, right) }
    / __ "*" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Mul, right) }
    / __ "/" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Div, right) }
    / __ "or" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Or, right) }
    / __ "and" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::And, right) }
    / __ "==" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Eq, right) }
    / __ "!=" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Ne, right) }
    / __ ">=" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Ge, right) }
    / __ "<=" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Le, right) }
    / __ ">" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Gt, right) }
    / __ "<" __ right:expr __ { ExpressionTail::Binary(BinaryOperator::Lt, right) }

expr_list -> Vec<Expression>
    = expr:wrapped_expr ** "," __ ","? { expr }

atom -> Expression
    = "(" __ expr:expr __ ")" { expr }
    / block:block { Expression::Block(Box::new(block)) }
    / nl:number_literal { Expression::NumberLiteral(Box::new(nl)) }
    / sl:string_literal { Expression::StringLiteral(Box::new(sl)) }
    / bl:boolean_literal { Expression::BooleanLiteral(Box::new(bl)) }
    / vl:void_literal { Expression::VoidLiteral(Box::new(vl)) }
    / id:id { Expression::Id(Box::new(id)) }

block -> Block
    = "{" __ body:block_body __ "}" { Block { body } }

id -> Id
    = #quiet<name:$([a-zA-Z_$][a-zA-Z_0-9]*) { Id{ name: name.to_owned() } }>
    / #expected("identifier")

lambda -> Lambda
    = "(" __ slots:slot_list __ ")" __  "=>" __ expression:expr {
        Lambda {
            slots,
            expression,
        }
    }

function -> Function
    = "function" space id:id __ "(" __ slots:slot_list __ ")" __ block:block {
        Function {
            id,
            slots,
            expression: Expression::Block(Box::new(block)),
        }
    }

slot_list -> Vec<Slot>
    = slots:wrapped_slot ** "," __ ","? { slots }

wrapped_slot -> Slot
    = __ slot:slot __ { slot }

slot -> Slot
    = id:id __ ty:slot_type_sufix? {
        Slot { id, ty: ty.unwrap_or(Id { name: String::from("Any") }) }
    }

slot_type_sufix -> Id
    = ":" __ ty:id { ty }

number_literal -> NumberLiteral
    = value:$([0-9]+ "."? [0-9]*) { NumberLiteral { value: value.parse().unwrap() } }

string_literal -> StringLiteral
    = "\"" value:$([^"]*) "\"" { StringLiteral { value: value.to_owned() } }

boolean_literal -> BooleanLiteral
    = "true" (! [a-zA-Z0-9_$]) { BooleanLiteral { value: true } }
    / "false" (! [a-zA-Z0-9_$]) { BooleanLiteral { value: false } }

void_literal -> VoidLiteral
    = "void" (! [a-zA-Z0-9_$]) { VoidLiteral { } }

space = #quiet<(whitespace / eol / comment)+>

__ = #quiet<(whitespace / eol / comment)*>

whitespace
    = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]

eol
    = "\n" / "\r\n" / "\r" / "\u{2028}" / "\u{2029}"

comment
    = "//" (!eol .)* eol
    / "/*" (!"*/" .)* "*/"
